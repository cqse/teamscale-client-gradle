import groovy.json.*

// Main task: process
// Pass parameter -Preport=PATH_TO_JACOCO_REPORT_ZIP
// Uploads to one or more TS projects
// Assumes that the zip file contains: coverage.xml, version.json

// where to archive successfully uploaded coverage zips
ext.archiveDir = "./archive"

// where to archive failed uploads
ext.failureDir = "./archive"

// type of reports that are being uploaded
ext.reportFormat = 'JACOCO'

// Teamscale configuration
ext.teamscale = [
    // upload is only performed if this is false
    dryRun: true,

    url: "",
    username: "",
    accesskey: "",

    // defaults should be fine
    timeout: [
        connect: 60,
        read: 60,
        write: 60,
    ],
]

// creates a temporary directory into which to unpack the zips
ext.workingDir = File.createTempDir()
ext.workingDir.deleteOnExit()

def fail(message) {
    System.err.println("FAILURE: $message")
    throw new RuntimeException(message)
}

if (!project.hasProperty("report")) {
    fail("You must pass -Preport=PATH_TO_JACOCO_REPORT_ZIP")
}

// load runtime dependencies
buildscript {
	dependencies {
		classpath fileTree("$rootDir/gradle/lib").include("**.jar")
	}
}

task cleanUpWorkingDirectory {
    doLast {
        delete project.workingDir
    }
}

task unzipReport(type: Copy) {
    println "Unzipping..."
    from(zipTree(report))
    into project.workingDir
}

task parsePartition {
    dependsOn unzipReport

    doLast {
        def contents = file("${project.workingDir}/version.json").text
        def jsonSlurper = new JsonSlurper()
        def versionObject = jsonSlurper.parseText(contents)
        parsePartition.ext.partition = versionObject.zone
        println "Partition: $parsePartition.ext.partition"
    }
}

task parseVersionsTxt {
    dependsOn unzipReport

    doLast {
        def contents = file("${project.workingDir}/version.json").text
        def jsonSlurper = new JsonSlurper()
        def versionObject = jsonSlurper.parseText(contents)
        parseVersionsTxt.ext.versionMapping = [:]
        versionObject.components.each {
            if (it.key == "SHA") {
                // ignore the SHA property, we don't need it
                // this is still in the files because we added
                // it during the pilot but we don't actually need it
                // this check and the SHA property can simply be
                // removed in the future
                return
            }
            def projectName = parseProject(it.key)
            parseVersionsTxt.ext.versionMapping[projectName] = it.value
        }
        println "Version Mapping: $parseVersionsTxt.ext.versionMapping"
    }
}

task uploadReport() {
    dependsOn unzipReport, parseVersionsTxt, parsePartition

    doLast {
        def reportFile = file("${project.workingDir}/coverage.xml")
        def versionMapping = parseVersionsTxt.ext.versionMapping
        def partition = parsePartition.ext.partition
        def message = "Coverage from $partition"

        uploadReport.ext.success = true
        println "  -> Uploading $report"

        versionMapping.each { project, timestamp ->
            println "  -> to project $project"
            println "     ... for timestamp $timestamp"

            if (teamscale.dryRun) {
                println "     ... in DRY-RUN mode"
                return
            }

            try {
                println "     -> " + uploadExternalReport(reportFile, project, timestamp, message, partition)
            } catch(e) {
                println "     -> Skipped ($e)"
                uploadReport.ext.success = false
            }
        }
    }
}

task archiveReport {
    dependsOn uploadReport

    doLast {
        def destination = archiveDir
        if (!uploadReport.ext.success) {
            destination = failureDir
        }

        println "  -> Archiving $report to $destination"
        copy {
            from report
            into destination
        }
        delete report
    }
}

// main task
task process {
    dependsOn uploadReport, archiveReport
    finalizedBy cleanUpWorkingDirectory
}

def createHttpClient() {
    return groovyx.net.http.OkHttpBuilder.configure {
        request.uri = teamscale.url
        request.headers['Authorization'] = "Basic " + "${teamscale.username}:${teamscale.accesskey}".bytes.encodeBase64().toString()

        clientConfig.clientCustomizer { okhttp3.OkHttpClient.Builder builder ->
            builder.connectTimeout(teamscale.timeout.connect, java.util.concurrent.TimeUnit.SECONDS);
            builder.writeTimeout(teamscale.timeout.write, java.util.concurrent.TimeUnit.SECONDS);
            builder.readTimeout(teamscale.timeout.read, java.util.concurrent.TimeUnit.SECONDS);
        }
    }
}

def uploadExternalReport(reportFile, project, timestamp, message, partition) {
    return createHttpClient().post(String) {
        request.uri.path = "/p/$project/external-report"
        request.contentType = 'multipart/form-data'
        request.uri.query = [
            t: timestamp,
            format: reportFormat,
            adjusttimestamp: true,
            message: message,
            partition: partition
        ]
        request.body = groovyx.net.http.MultipartContent.multipart {
            part 'report', reportFile.name, 'text/plain', reportFile
        }
        request.encoder 'multipart/form-data', groovyx.net.http.OkHttpEncoders.&multipart
    }
}

def parseProject(gitUrl) {
    // URLs look like this: ssh://somepath/PROJECT.git
    def projectMatcher = gitUrl =~ /.*\/([^\/\.]*)\.git/
    if (!projectMatcher) {
        fail("Unable to parse Git URL: $gitUrl")
    }
    return projectMatcher[0][1]
}

