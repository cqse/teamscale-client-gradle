apply from: "$rootDir/gradle/base-teamscale.gradle"


import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import groovy.transform.Canonical
import groovy.xml.XmlUtil

// TODO find a way to general import buildscript deps...
buildscript {
	dependencies {
		classpath fileTree("$rootDir/gradle/lib").include("**.jar")
	}
}

ext {
	teamscale.url = "http://..."
	teamscale.username = "admin"
	teamscale.accesskey = "tokentoken"

	// Tool for which the dashboard is created. Can be "tqe", "tsa" (or "tga")
	TOOL = ""

	// The path to the applications.json of the porfolio dashboard
	PORTFOLIO_DATA_PATH = ""

	// The name of the dashboard which is the template for all others
	DASHBOARD_TEMPLATE = ""

	// Checks if a dashboard should be overwritten if it already exist
	OVERWRITE = false

	// Handles the case where dashboard should be created if the project does not exist in teamscale,
	// but is defined in the portfolio properties.
	PROJECT_MUST_EXIST = true

	// Mapping from the goal to its short description
	QUALITY_GOAL_DESCRIPTIONS = [
		0: "TBD",
		1: "indifferent",
		2: "preserving",
		3: "improving",
		4: "perfective"
	]

	// Id of the dummy project. Will be used for replacing values, for example, in sharing
	DUMMY_PROJECT = "dummy"
}

// ### Definitions ###
/** Contains all needed info about the project */
@Canonical
class ProjectInfo {
	String id
	String path
	String qualifiedName
	String dashboardName
	int qualityGoal
	@Nullable
	String profile
}

/** Wrapper for the Dashboard XML */
class Dashboard {
	groovy.util.slurpersupport.NodeChild xml

	Dashboard(xml) {
		this.xml = xml
	}

	String getName() {
		return "" + this.xml.payload.owner + "/" + this.xml.payload.name
	}

	String toString() {
		return XmlUtil.serialize(this.xml)
	}
}

// ### Methods ###
/** Checks if the project with the given id exists */
def getProjectInfo(id) {
	def http = teamscale.httpClient(teamscale)
	return http.get {
		request.uri.path = "$teamscale.prefix/create-project/$id"

		response.failure {
			return null
		}
	}
}

/**
 * Fetches the info for all projects from the applications.json from the portfolio dashboard and teamscale
 *
 * @return List<ProjectInfo>
 */
def getProjectInfos(tool, dataPath) {
	def propertiesFile = new File(dataPath)
	assert propertiesFile.exists(): "File \"$dataPath\" does not exist"

	def data = new JsonSlurper().parse(propertiesFile)

	def projectInfos = []
	data.each { projectEntry ->
		def project = projectEntry.value
		if (!project[tool]) {
			return
		}

		def teamscaleId = project[tool].teamscale.project.split("/").last()

		def path = project[tool].teamscale.path.split("/") as List
		path = path.subList(path.indexOf("code.html#") + 2, path.size()).join("/")


		def qualifiedName = project.name
		def dashboardName = URLDecoder.decode(project[tool].teamscale.dashboard.split("admin%2F").last(), "utf-8")
		def qualityGoal = project[tool].qualityGoal
		def profile = getProjectInfo(teamscaleId)?.profile?.text()

		assert teamscaleId && qualifiedName && dashboardName && qualityGoal != null: "Insufficient data"

		projectInfos.add(new ProjectInfo(teamscaleId, path, qualifiedName, dashboardName, qualityGoal, profile))
	}

	return projectInfos
}

/** Returns the Dashboard template */
def getDashboardTemplate() {
	return downloadDashboard(DASHBOARD_TEMPLATE)
}

/**
 * Downloads the dashboard with the given name.
 * If the saveTo parameter is not set the dashboard will only be downloaded to a temp file, which will be deleted.
 */
def downloadDashboard(name, saveTo = null) {
	def http = teamscale.httpClient(teamscale)
	def path = saveTo ?: "tmp/tmp.tsdashboard"

	def file = new File("$rootDir/$path")
	try {
		// The request does return a file handle, but if the dashboard doesn't exist it will still write the file
		// with the 404 message of the server. This cannot be parsed further in the script, so we want to return null
		def result = http.get {
			request.uri.path = "$teamscale.prefix/dashboard-export/${name}.tsdashboard"
			groovyx.net.http.optional.Download.toFile(delegate, file)
			response.failure { resp, reader ->
				println "[WARNING] Dashboard \"$name\" does not exist on $teamscale.url"
				return null
			}
		}

		return result?.text
	} finally {
		if (!saveTo) {
			file?.delete()
		}
	}
}

/** Returns a list of all dashboards in Teamscale */
def getDashboards() {
	def http = teamscale.httpClient(teamscale)
	return http.get {
		request.uri.path = "$teamscale.prefix/dashboards"
	}.childNodes().collect {
		return it.text()
	}
}

/**
 * Uploads the given dashboard to teamscale
 *
 * @param dashboard Dashboard
 */
def uploadDashboard(dashboard, projectId) {
	def http = teamscale.httpClient(teamscale)
	println "[$projectId] Uploading dashboard \"${dashboard.getName()}\""
	http.post {
		request.uri.path = "$teamscale.prefix/dashboard-export"
		request.encoder "multipart/form-data", groovyx.net.http.OkHttpEncoders.&multipart
		request.contentType = "multipart/form-data"

		request.body = groovyx.net.http.MultipartContent.multipart {
			field "dashboardDescriptor", dashboard.toString()
		}

		response.failure failure
	}
}

/** Sets the sharing for the given dashboard */
def setSharing(dashboard, projectInfo) {
	dashboard.payload.projectAccessEntries.children().each { child ->
		if (child.userOrGroup == DUMMY_PROJECT) {
			child.userOrGroup = projectInfo.id
		}
	}
}

/**
 * Creates a dashboard from the template and the given information.
 *
 * @param info ProjectInfo
 * @return Dashboard
 */
def createDashboard(template, projectInfo) {
	// parse the XML
	def xml = new XmlSlurper().parseText(template)

	// change XML
	xml.payload.name = projectInfo.dashboardName

	// Set sharing
	setSharing(xml, projectInfo)

	// change JSON
	def json = new JsonSlurper().parseText(xml.payload.descriptorJSON.text())
	json.widgets.each { widget ->
		// Label Title
		if (widget["widget-id"] == "label") {
			widget.Title = widget.Title
				.replaceFirst(/<[^>]+>/, projectInfo.qualifiedName)
				.replace("<QG>", projectInfo.qualityGoal as String)
				.replace("<DESCRIPTION>", QUALITY_GOAL_DESCRIPTIONS[projectInfo.qualityGoal])
			return
		}

		// Project paths
		if (widget.Path) {
			widget.Path.project = projectInfo.id
			widget.Path.path = projectInfo.path
		}

		// Baselines
		if (widget.Trend && widget.Trend.type == "BASELINE") {
			widget.Trend.value.project = projectInfo.id
		}
	}
	xml.payload.descriptorJSON = new JsonBuilder(json).toPrettyString()

	return new Dashboard(xml)
}

// ### Tasks ###
/** Creates and uploads a dashboard for all projects defined in the portfolio dashboard */
task createUniformDashboardForAllProjects {
	doLast {
		def template = getDashboardTemplate()
		if (!template) {
			return
		}
		def propertyInfos = getProjectInfos(TOOL, PORTFOLIO_DATA_PATH)
		def existingDashboards = getDashboards()

		propertyInfos.each { propertyInfo ->
			// Check if project exists
			if (PROJECT_MUST_EXIST && !propertyInfo.profile) {
				println "[WARNING] \"$propertyInfo.id\" does not exist on $teamscale.url"
				return
			}

			def dashboard = createDashboard(template, propertyInfo)

			if (!OVERWRITE && existingDashboards.contains(dashboard.getName())) {
				println "[WARNING] Dashboard \"${dashboard.getName()}\" already exists"
				return
			}

			uploadDashboard dashboard, propertyInfo.id
		}
	}
}

/** Deletes ALL dashboards (without asking)! */
task deleteAllDashboards {
	doLast {
		def http = teamscale.httpClient(teamscale)
		getDashboards().each { dashboard ->
			http.delete {
				request.uri.path = "$teamscale.prefix/dashboards/$dashboard"
				response.failure { resp, reader ->
					println request.uri
					println reader
				}
			}
		}
	}
}

/** Exports all dashboards to the tmp/backup directory */
task backupAllDashboards {
	doLast {
		getDashboards().each { dashboard ->
			def name = URLEncoder.encode(dashboard, "UTF-8")
			new File("$rootDir/tmp/backup/").mkdirs() createMonthly
			downloadDashboard(dashboard, "tmp/backup/${name}.tsdashboard")
		}
	}
}