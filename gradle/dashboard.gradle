apply from: "$rootDir/gradle/base-teamscale.gradle"

import groovyx.net.http.HttpException
import groovy.json.JsonSlurper
import groovy.json.JsonBuilder
import groovy.transform.Canonical
import groovy.xml.XmlUtil

// TODO find a way to general import buildscript deps...
buildscript {
	dependencies {
		classpath fileTree("$rootDir/gradle/lib").include("**.jar")
	}
}

ext {
	teamscale.url = "http://..."
	teamscale.username = "admin"
	teamscale.accesskey = "tokentoken"

	/** Tool for which the dashboard is created. Can be "tqe", "tsa" (or "tga") */
	TOOL = ""

	/** The path to the applications.json of the porfolio dashboard */
	PORTFOLIO_DATA_PATH = ""

	/** The name of the dashboard which is the template for all others */
	DASHBOARD_TEMPLATE = ""

	/** Checks if a dashboard should be overwritten if it already exist */
	OVERWRITE = false

	/** Handles the case if a dashboard should be created if the project does not exist */
	PROJECT_MUST_EXIST = true

	/** Mapping from the goal to its short description */
	QUALITY_GOAL_DESCRIPTIONS = [
		0: "TBD",
		1: "indifferent",
		2: "preserving",
		3: "improving",
		4: "perfective"
	]

	DUMMY_PROJECT = "dummy"
}

// ### Definitions ###
/** Contains all needed info about the project */
@Canonical
class ProjectInfo {
	String id
	String qualifiedName
	String dashboardName
	int qualityGoal
	@Nullable
	String profile
}

/** Wrapper for the Dashboard XML */
class Dashboard {
	groovy.util.slurpersupport.NodeChild xml

	Dashboard(xml) {
		this.xml = xml
	}

	String getName() {
		return "" + this.xml.payload.owner + "/" + this.xml.payload.name
	}

	String toString() {
		return XmlUtil.serialize(this.xml)
	}
}

// ### Methods ###
/**
 * Checks if the project with the given id exists
 */
ext.getProjectInfo = { id ->
	def http = teamscale.httpClient(teamscale)
	return http.get {
		request.uri.path = "/create-project/$id"

		response.failure {
			return null
		}
	}
}

/**
 * Fetches the info for all projects from the applications.json from the portfolio dashboard and teamscale
 *
 * @param tool String "tqe" or "tga"
 * @param dataPath String Path to the applications.json
 *
 * @return List<ProjectInfo>
 */
ext.getProjectInfos = { tool, dataPath ->
	def propertiesFile = new File(dataPath)
	assert propertiesFile.exists(): "File \"$dataPath\" does not exist"

	def data = new JsonSlurper().parse(propertiesFile)

	def projectInfos = []
	data.each { project ->
		if (!project[tool]) {
			return
		}

		def id = project[tool].teamscale.project.split('/').last()
		def qualifiedName = project.name
		def dashboardName = URLDecoder.decode(project[tool].teamscale.dashboard.split("admin%2F").last(), "utf-8")
		def qualityGoal = project[tool].qualityGoal
		def profile = getProjectInfo(id)?.profile?.text()

		assert id &&  qualifiedName && dashboardName && qualityGoal != null: "Insufficient data"

		projectInfos.add(new ProjectInfo(id, qualifiedName, dashboardName, qualityGoal, profile))
	}

	return projectInfos
}

/**
 * Returns the Dashboard template
 *
 * @return String
 */
ext.getDashboardTemplate = {
	return downloadDashboard(DASHBOARD_TEMPLATE)
}

/**
 * Downloads the dashboard with the given name.
 * If the saveTo parameter is not set the dashboard will only be downloaded to a temp file, which will be deleted.
 *
 * @param name String
 * @param saveTo String Path where the dashboard will be saved to
 * @return String The dashboard XML
 */
ext.downloadDashboard = {name, saveTo = null ->
	def http = teamscale.httpClient(teamscale)
	def path = saveTo ?: "tmp/tmp.tsdashboard"

	def file = new File("$rootDir/$path")
	try {
		// The request does return a file handle, but if the dashboard doesn't exist it will still write the file
		// with the 404 message of the server. This cannot be parsed further in the script, so we want to return null
		def result = http.get {
			request.uri.path = "/dashboard-export/${name}.tsdashboard"
			groovyx.net.http.optional.Download.toFile(delegate, file)
			response.failure { resp, reader ->
				println "WARNING: Dashboard \"$name\" does not exist on $teamscale.url"
				return null
			}
		}

		return result?.text
	} finally {
		if(!saveTo) {
			file?.delete()
		}
	}
}

/**
 * Returns a list of all dashboards in Teamscale
 *
 * @return List<String>
 */
ext.getDashboards = {
	def http = teamscale.httpClient(teamscale)
	return http.get {
		request.uri.path = "/dashboards"
	}.childNodes().collect {
		return it.text()
	}
}

/**
 * Uploads the given dashboard to teamscale
 *
 * @param dashboard Dashboard
 * @param projectId String
 */
ext.uploadDashboard = { dashboard, projectId ->
	def http = teamscale.httpClient(teamscale)
	print "Uploading dashboard for $projectId to $teamscale.url: "
	println http.post {
		request.uri.path = "/dashboard-export"
		request.encoder "multipart/form-data", groovyx.net.http.OkHttpEncoders.&multipart
		request.contentType = "multipart/form-data"

		request.body = groovyx.net.http.MultipartContent.multipart {
			field "dashboardDescriptor", dashboard.toString()
		}

		response.failure failure
	}
}

/** Sets the sharing for the given dashboard */
ext.setSharing = { dashboard, projectInfo ->
	// TODO: Group sharing for TSA
	dashboard.payload.projectAccessEntries.children().each { child ->
		if(child.userOrGroup == DUMMY_PROJECT) {
			child.userOrGroup = projectInfo.id
		}
	}
	//dashboard.payload.projectAccessEntries.children().findAll {true}.replaceNode {}
	//dashboard.payload.projectAccessEntries.appendNode {
	//	'com.teamscale.index.dashboard.DashboardAccessEntry'() {
	//		userOrGroup "$projectInfo.id"
	//		accessRight  "READ"
	//	}
	//}
}

/**
 * Creates a dashboard from the template and the given information.
 *
 * @param template String
 * @param info ProjectInfo
 * @return Dashboard
 */
ext.createDashboard = { template, projectInfo ->
	// parse the XML
	def xml = new XmlSlurper().parseText(template)

	// change XML
	xml.payload.name = projectInfo.dashboardName

	// Set sharing
	setSharing(xml, projectInfo)

	// change JSON
	def json = new JsonSlurper().parseText(xml.payload.descriptorJSON.text())
	json.widgets.each { widget ->
		// Label Title
		if(widget["widget-id"] == "label") {
			widget.Title = widget.Title
				.replaceFirst(/<[^>]+>/, projectInfo.qualifiedName)
				.replace("<QG>", projectInfo.qualityGoal as String)
				.replace("<DESCRIPTION>", QUALITY_GOAL_DESCRIPTIONS[projectInfo.qualityGoal])
			return
		}

		// Project paths
		if(widget.Path) {
			widget.Path.project = projectInfo.id
		}

		// Baselines
		if(widget.Trend && widget.Trend.type == "BASELINE") {
			widget.Trend.value.project = projectInfo.id
		}
	}
	xml.payload.descriptorJSON = new JsonBuilder(json).toPrettyString()

	return new Dashboard(xml)
}

// ### Tasks ###
/** Creates and uploads a dashboard for all projects defined in the portfolio dashboard */
task createUniformDashboardForAllProjects {
	doLast {
		def template = getDashboardTemplate()
		if(!template) {
			return
		}
		def propertyInfos = getProjectInfos(TOOL, PORTFOLIO_DATA_PATH)
		def existingDashboards = getDashboards()

		propertyInfos = propertyInfos.subList(0, 2)
		propertyInfos.each { propertyInfo ->
			// Check if project exists
			if (PROJECT_MUST_EXIST && !propertyInfo.profile) {
				println "WARNING: \"$propertyInfo.id\" does not exist on $teamscale.url... Skipping"
				return
			}

			def dashboard = createDashboard(template, propertyInfo)

			if (!OVERWRITE && existingDashboards.contains(dashboard.getName())) {
				println "WARNING: Dashboard \"${dashboard.getName()}\" already exists... Skipping"
				return
			}

			uploadDashboard dashboard, propertyInfo.id
		}
	}
}

task deleteAllDashboards {
	doLast {
		def http = teamscale.httpClient(teamscale)
		getDashboards().each { dashboard ->
			http.delete {
				request.uri.path = "/dashboards/$dashboard"
				response.failure { resp, reader ->
					println request.uri
					println reader
				}
			}
		}
	}
}

task backupAllDashboards {
	doLast {
		getDashboards().each { dashboard ->
			def name = URLEncoder.encode(dashboard, "UTF-8")
			new File("$rootDir/tmp/backup/").mkdirs()createMonthly
			downloadDashboard(dashboard, "tmp/backup/${name}.tsdashboard")
		}
	}
}