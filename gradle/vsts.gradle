apply from: "$rootDir/gradle/base-teamscale.gradle"

import groovy.transform.Canonical
import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import java.time.Instant

@Canonical
class Finding {
	String id
	String message
    String file
	String line
}


// TODO: add build time to uploads


// TODO find a way to general import buildscript deps...
buildscript {
	dependencies {
		classpath fileTree("$rootDir/gradle/lib").include("**.jar")
	}
}

ext {
	vsts = [
		// Map of VSTS/TFS URLs to login credentials if NTLM should not be used
		credentials: [
			// E.g. Basic AUTH:
			// 'https://my-account.visualstudio.com': [
			// 	type: 'basic',
			// 	username: 'foo',
			// 	password: 'bar'
			// ]
		],

		// Map of VSTS builds to process
		builds: [
			// Sample:
			// 'https://my-account.visualstudio.com': [
			// 	'MyProject': [
			// 		'MyBuild': [
			// 			logs: true
			// 		]
			// 	]
			// ]
		],

		loganalyzer: [
			msbuild: [
				pattern: /(?:[\d\s\.:]*\d+>)?\s*(.*)\(([0-9]+)(?:,[0-9]+)?\).*warning[:\s]*((?:CS|SCS|SEC)\w*):\s?(.+?)\s+(?:\[([^\[]+)\]$)/,
				convert: { matches ->
					def match = matches[0]
					def path = match[1].replace('\\', '/')
					def project = match[5].replace('\\', '/').split('/').dropRight(1).join('/') // removes the csproject
					if (!path.startsWith(project)) {
						path = "$project/$path"
					}

					return new Finding(id: match[3], message: match[4], file: path, line: match[2])
				}
			]
		],

		cacheFile: file("${project.name}_vsts_cache.json"),

		httpClient: { url, credentials ->
			return groovyx.net.http.OkHttpBuilder.configure {
				request.uri = url
				request.headers['Authorization'] = "Basic " + "${credentials.username}:${credentials.password}".bytes.encodeBase64().toString()
			}
		}
	]

    pprint = { input ->
        println new JsonBuilder(input).toPrettyString()
    }

    appendPartitionName = { partition, divider, definition, numberOfDefinitions ->
        if(numberOfDefinitions > 1) {
            assert definition.options.partition : "Definition '$definition.name' has $numberOfDefinitions definitions:" +
            "\nYou need to set the 'partition' property for every definition in your 'project.gradle'"

            partition += divider + definition.options.partition
        }

        return partition
    }

    getExecutionTime = { startDate, endDate ->
        def start = Instant.parse(startDate).toEpochMilli()
        def end = Instant.parse(endDate).toEpochMilli()
        return (end - start) / 1000
    }
}

def buildDefinitions = [:]
def cache = [
	lastProcessedCompletedTime: [:]
]

task collecBuildDefinitions {
	doLast {
		vsts.builds.each { vstsUrl, vstsProjects ->
			vstsProjects.each { vstsProjectName, vstsBuilds ->
				def http = vsts.httpClient(vstsUrl, vsts.credentials[vstsUrl])
				def response = http.get {
					request.uri.path = "/$vstsProjectName/_apis/build/definitions"
					request.uri.query = [
						'api-version': '4.1',
						'includeLatestBuilds': true
					]
				}

				response.value.each { vstsBuildDefinition ->
					if (!vstsBuilds.containsKey(vstsBuildDefinition.name)) {
						return;
					}

					def buildDefinitionKey = [
                        url: vstsUrl,
                        project: vstsProjectName,
                        name: vstsBuildDefinition.name,
                        options: vstsBuilds[vstsBuildDefinition.name]
                    ]

					buildDefinitions[buildDefinitionKey] = [
						id: vstsBuildDefinition.id,
						lastCompletedTime: Instant.parse(vstsBuildDefinition.latestCompletedBuild.finishTime),
						http: http,
						builds: []
					]
				}
			}
		}
	}
}

task collectNewBuilds(dependsOn: collecBuildDefinitions) {
	doLast {
		if (vsts.cacheFile?.exists() && vsts.cacheFile.text) {
			cache = new JsonSlurper().parseText(vsts.cacheFile.text)
		}

		buildDefinitions.each { definition, definitionData ->
			def cacheKey = "$definition.url/$definition.project/$definition.name"
			def lastProcessedCompletedTime = cache.lastProcessedCompletedTime[cacheKey]
			if (!lastProcessedCompletedTime) {
				lastProcessedCompletedTime = Instant.EPOCH
			} else {
				lastProcessedCompletedTime = Instant.parse(lastProcessedCompletedTime)
				if (definitionData.lastCompletedTime <= lastProcessedCompletedTime) {
					return
				}
			}

			def response = definitionData.http.get {
				request.uri.path = "/$definition.project/_apis/build/builds"
				request.uri.query = [
					'api-version': '4.1',
					'definitions': definitionData.id,
                    // TODO: not working perfectly -> SampleApp old build from 2017, cache time is May 2018
					'minTime': lastProcessedCompletedTime.plusNanos(1),
					'status': 'completed',
					'queryOrder': 'finishTimeAscending',
				]
			}

            // TODO: Check that the build status is "completed"
			response.value.each { build ->
				definitionData.builds += [
					details: build,
					queueTime: Instant.parse(build.queueTime),
					findings: new HashSet<Finding>()
				]
			}

			// TODO update step by step?
			cache.lastProcessedCompletedTime[cacheKey] = definitionData.lastCompletedTime.toString()
		}

		// TODO move after build info is uploaded
		if (vsts.cacheFile) {
			//vsts.cacheFile.write(new JsonBuilder(cache).toPrettyString())
		}
	}
}

task parseBuildLogs(dependsOn: collectNewBuilds) {
	doLast {
		buildDefinitions.each { definition, definitionData ->
			definitionData.builds.each { build ->
				def logs = definitionData.http.get {
					request.uri.path = "/$definition.project/_apis/build/builds/$build.details.id/logs"
					request.uri.query = [ 'api-version': '4.1' ]
				}

				logs.value.each { logRef ->
					// TODO maybe we should get the log content in batches of lines?
					def log = definitionData.http.get {
						request.uri.path = "/$definition.project/_apis/build/builds/$build.details.id/logs/$logRef.id"
						request.uri.query = [ 'api-version': '4.1' ]
					}

					// Strip timestamp margin
					// TODO use pattern or use on per-line basis
					if (log[10] == "T" && log[27] == "Z" && log[28] == " ") {
						log = log.stripIndent(29)
					}

					log.eachLine { line ->
						vsts.loganalyzer.each { type, analyzer ->
							if (line =~ analyzer.pattern) {
								build.findings += analyzer.convert(java.util.regex.Matcher.lastMatcher)
							}
						}
					}

				}
			}
		}
	}
}

task getTestResults(dependsOn: collectNewBuilds) {
    doLast {
		buildDefinitions.each { definition, definitionData ->
			definitionData.builds.each { build ->
                def testRuns = definitionData.http.get {
                    request.uri.path = "/$definition.project/_apis/test/Runs"
                    request.uri.query = [
                        "api-version" : "4.1",
                        "builduri" : "vstfs:///Build/Build/$build.details.id"
                    ]
                }

                def results = []
                testRuns.value.each { run ->
                    results.add(definitionData.http.get {
                        request.uri.path = "/$definition.project/_apis/test/runs/$run.id"
                        request.uri.query = [:]
                    })
                }


                build.testResult = results
            }
        }
    }
}

task uploadTestResults(dependsOn: getTestResults) {
    doLast {
		def http = teamscale.httpClient(teamscale)
        buildDefinitions.each { definition, data ->
            data.builds.sort{ it.queueTime }.each { build ->
                if(build.testResult.size() < 1) {
                    println " No tests run for build $build.details.buildNumber"
                    return
                }

                // Aggregate if there are multiple runs in one build
                def result = ["passed": 0, "total": 0, "time": 0]
                build.testResult.each { run ->
                    result.passed += run.passedTests
                    result.total += run.totalTests
                    result.time += getExecutionTime(run.startedDate, run.completedDate)
                }

                // Upload the result
                def partition = appendPartitionName("Test", ": ", definition, buildDefinitions.size())
                def path = appendPartitionName("Test Success", "/", definition, buildDefinitions.size())

                println " Uploading test results to $teamscale.project for build $build.details.buildNumber"
                println "     -> " + http.put {
                    request.uri.path = "/p/$teamscale.project/add-non-code-metrics"
                    request.contentType = "application/json"
                    request.uri.query = [
                        "skip-session": true,
                        "message": "External Analysis ($partition)",
                        "partition": partition
                    ]

                    request.body = [[
                        "path": path,
                        "content": "$result.passed/$result.total tests passed",
                        "time": result.time,
                        "assessment" : [
                            "GREEN" : result.passed,
                            "RED": result.total - result.passed
                        ]
                    ]]
                }
            }
        }
    }
}

task uploadBuildStatus(dependsOn: collectNewBuilds) {
    def buildResultMap = [
        "failed" : [
            "assessment": "RED",
            "content": "Build is unstable"
        ],
        "succeeded": [
            "assessment": "GREEN",
            "content": "Build is stable"
        ]
    ]

    doLast {
		def http = teamscale.httpClient(teamscale)

        buildDefinitions.each { definition, data ->
            data.builds.sort{ it.queueTime }.each { build ->
                if(build.details.status != "completed") {
                    return
                }


                def buildResult = buildResultMap[build.details.result]
                def partition = appendPartitionName("Build", ": ", definition, buildDefinitions.size())

                println " Uploading build status to $teamscale.project for build $build.details.buildNumber"
                println "     -> " + http.put {
                    request.uri.path = "/p/$teamscale.project/add-non-code-metrics"
                    request.contentType = "application/json"
                    request.uri.query = [
                        "skip-session": true,
                        "message": "External Analysis ($partition)",
                        "partition": appendPartitionName("Build", ": ", definition, buildDefinitions.size())
                    ]

                    request.body = [[
                        "path": appendPartitionName("Build Stability", "/", definition, buildDefinitions.size()),
                        "content": buildResult.content,
                        "time": getExecutionTime(build.details.startTime, build.details.finishTime),
                        "assessment" : [ "$buildResult.assessment" : 1 ]
                    ]]
                }
            }
        }
    }
}

task uploadBuildFindings(dependsOn: parseBuildLogs) {
	doLast {
		def http = teamscale.httpClient(teamscale)
		def builds = buildDefinitions.collectMany { _, definitionData -> definitionData.builds }.sort { it.queueTime }
		builds.each { build ->
            // Upload findings
			println "  Uploading ${build.findings.size()} findings to $teamscale.project"
		    println "     -> " + http.put {
				request.uri.path = "/p/$teamscale.project/add-external-findings"
				request.contentType = 'application/json'
                // TODO: Partition and Message
				request.uri.query = [
					//"t": build.queueTime.toEpochMilli(),
					"message": "VSTS Build Findings",
					"partition": "vsts build findings",
                    "skip-session": "true"
				]

                def fileFindings = build.findings.groupBy({ finding -> finding.file }).collect {
                    k, v -> ["path" : k, "findings": v.collect {
                        finding ->
                        [
                            "findingTypeId": finding.id,
                            "message": finding.message,
                            "startLine": finding.line,
                            "endLine": finding.line
                        ]
                    }]
                }

				request.body = fileFindings
			}
		}
	}
}
