apply from: "$rootDir/gradle/base-teamscale.gradle"

import groovy.transform.Canonical
import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import java.time.Instant

@Canonical
class Finding {
	String id
	String message
    String file
	String line
}

// TODO find a way to general import buildscript deps...
buildscript {
	dependencies {
		classpath fileTree("$rootDir/gradle/lib").include("**.jar")
	}
}

ext {
	vsts = [
		// Map of VSTS/TFS URLs to login credentials if NTLM should not be used
		credentials: [
			// E.g. Basic AUTH:
			// 'https://my-account.visualstudio.com': [
			// 	type: 'basic',
			// 	username: 'foo',
			// 	password: 'bar'
			// ]
		],

		// Map of VSTS builds to process
		builds: [
			// Sample:
			// 'https://my-account.visualstudio.com': [
			// 	'MyProject': [
			// 		'MyBuild': [
			// 			logs: true
			// 		]
			// 	]
			// ]
		],

		loganalyzer: [
			msbuild: [
				pattern: /(?:[\d\s\.:]*\d+>)?\s*(.*)\(([0-9]+)(?:,[0-9]+)?\).*warning[:\s]*((?:CS|SCS|SEC)\w*):\s?(.+?)\s+(?:\[([^\[]+)\]$)/,
				convert: { matches ->
					def match = matches[0]
					// TODO doesn't replace all \\
					def path = match[1].replace('\\', '/')
					def project = match[5].replace('\\', '/').split('/').dropRight(1).join('/') // removes the csproject
					if (!path.startsWith(project)) {
						path = "$project/$path"
					}

					return new Finding(id: match[3], message: match[4], file: match[1], line: match[2])
				}
			]
		],

		cacheFile: file("${project.name}_vsts_cache.json"),

		httpClient: { url, credentials ->
			return groovyx.net.http.OkHttpBuilder.configure {
				request.uri = url
				request.headers['Authorization'] = "Basic " + "${credentials.username}:${credentials.password}".bytes.encodeBase64().toString()
			}
		}
	]
}

def buildDefinitions = [:]
def cache = [
	lastProcessedCompletedTime: [:]
]

task vstsCollectBuildDefinitions {
	doLast {
		vsts.builds.each { vstsUrl, vstsProjects ->
			vstsProjects.each { vstsProjectName, vstsBuilds ->
				def http = vsts.httpClient(vstsUrl, vsts.credentials[vstsUrl])
				def response = http.get {
					request.uri.path = "/$vstsProjectName/_apis/build/definitions"
					request.uri.query = [
						'api-version': '4.1',
						'includeLatestBuilds': true
					]
				}

				response.value.each { vstsBuildDefinition ->
					if (!vstsBuilds.containsKey(vstsBuildDefinition.name)) {
						return;
					}

					def buildDefinitionKey = [url: vstsUrl, project: vstsProjectName, name: vstsBuildDefinition.name]
					buildDefinitions[buildDefinitionKey] = [
						id: vstsBuildDefinition.id,
						lastCompletedTime: Instant.parse(vstsBuildDefinition.latestCompletedBuild.finishTime),
						http: http,
						builds: []
					]
				}
			}
		}
	}
}

task vstsCollectNewBuilds(dependsOn: vstsCollectBuildDefinitions) {
	doLast {
		if (vsts.cacheFile?.exists() && vsts.cacheFile.text) {
			cache = new JsonSlurper().parseText(vsts.cacheFile.text)
		}

		buildDefinitions.each { definition, definitionData ->
			def cacheKey = "$definition.url/$definition.project/$definition.name"
			def lastProcessedCompletedTime = cache.lastProcessedCompletedTime[cacheKey]
			if (!lastProcessedCompletedTime) {
				lastProcessedCompletedTime = Instant.EPOCH
			} else {
				lastProcessedCompletedTime = Instant.parse(lastProcessedCompletedTime)
				if (definitionData.lastCompletedTime <= lastProcessedCompletedTime) {
					return
				}
			}

			def response = definitionData.http.get {
				request.uri.path = "/$definition.project/_apis/build/builds"
				request.uri.query = [
					'api-version': '4.1',
					'definitions': definitionData.id,
					'minTime': lastProcessedCompletedTime.plusNanos(1),
					'status': 'completed',
					'queryOrder': 'finishTimeAscending',
				]
			}

			response.value.each { build ->
				definitionData.builds += [
					details: build,
					queueTime: Instant.parse(build.queueTime),
					findings: new HashSet<Finding>()
				]
			}

			// TODO update step by step?
			cache.lastProcessedCompletedTime[cacheKey] = definitionData.lastCompletedTime.toString()
		}

		// TODO move after build info is uploaded
		if (vsts.cacheFile) {
			//vsts.cacheFile.write(new JsonBuilder(cache).toPrettyString())
		}
	}
}

task vstsParseBuildLogs(dependsOn: vstsCollectNewBuilds) {
	doLast {
		buildDefinitions.each { definition, definitionData ->
			definitionData.builds.each { build ->
				def logs = definitionData.http.get {
					request.uri.path = "/$definition.project/_apis/build/builds/$build.details.id/logs"
					request.uri.query = [ 'api-version': '4.1' ]
				}

				logs.value.each { logRef ->
					// TODO maybe we should get the log content in batches of lines?
					def log = definitionData.http.get {
						request.uri.path = "/$definition.project/_apis/build/builds/$build.details.id/logs/$logRef.id"
						request.uri.query = [ 'api-version': '4.1' ]
					}

					// Strip timestamp margin
					// TODO use pattern or use on per-line basis
					if (log[10] == "T" && log[27] == "Z" && log[28] == " ") {
						log = log.stripIndent(29)
					}

					log.eachLine { line ->
						vsts.loganalyzer.each { type, analyzer ->
							if (line =~ analyzer.pattern) {
								build.findings += analyzer.convert(java.util.regex.Matcher.lastMatcher)
							}
						}
					}

				}
			}
		}
	}
}

task vstsUpload(dependsOn: vstsParseBuildLogs) {
	doLast {
		def http = teamscale.httpClient(teamscale)
		def builds = buildDefinitions.collectMany { _, definitionData -> definitionData.builds }.sort { it.queueTime }
		builds.each { build ->
			println "  Uploading ${build.findings.size()} findings to $teamscale.project"
			println "     -> " + http.post(String) {
				//request.uri.path = "/p/$project/finding-upload"
				request.contentType = 'application/json'
				request.uri.query = [
					t: build.queueTime.toEpochMilli(),
					adjusttimestamp: true,
					message: "Findings from build XXX",
					partition: "TODO"
				]
				// TODO use JsonBuilder.Options and JsonOutput.prettyPrint to ignore originalClassName and contentHash fields
				request.body = new JsonBuilder(build.findings).toPrettyString()
			}
		}
	}
}