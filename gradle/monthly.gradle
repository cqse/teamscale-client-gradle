apply from: "$rootDir/gradle/base-teamscale.gradle"

import groovy.json.JsonBuilder

ext {
	teamscale.url = "http://..."
	teamscale.username = "admin"
	teamscale.accesskey = "tokentoken"

	// The issue query for the monthly assessment
	// START and END will be replaced with dates
	ISSUE_QUERY = "('Work Item Type' != Task and closed=true and inState(closed=true) >= START and " +
		"inState(closed=true) < END) or ('Work Item Type' = Task and hasParent(closed=true and " +
		"inState(closed=true) >= START and inState(closed=true) < END)) or ('Work Item Type' = Task and " +
		"parent = '' and closed=true and inState(closed=true) >= START and inState(closed=true) < END)"
}

/** Returns all projects currently configured in teamscale */
def getProjects() {
	def http = teamscale.httpClient(teamscale)
	return http.get {
		request.uri.path = "/projects"
	}.childNodes().collect {
		return it.text()
	}
}

def createBaseline(project, name, date) {
	def timestamp = Math.max(date.getTime() as long, getFirstCommitTimestamp(project))

	def http = teamscale.httpClient(teamscale)
	println "Creating Baseline \"$name\" for \"$project\""
	println "    -> " + http.put {
		request.uri.path = "/p/$project/baselines/$name"
		request.contentType = "application/json"
		request.body = new JsonBuilder([
			"description": "",
			"name"       : name,
			"timestamp"  : timestamp
		]).toPrettyString()
		response.failure failure
	}
}

/** Returns all currently defined for the given project */
def getBaselines(project) {
	def http = teamscale.httpClient(teamscale)
	return http.get {
		request.uri.path = "/p/$project/monthly"
		response.failure failure
	}.childNodes().collect {
		return it.text()
	}
}

/**
 * Returns the timestamp of the first commit of the given project.
 * Should be used to prevent the creation of a baseline before the project even started.
 */
def getFirstCommitTimestamp(project) {
	def http = teamscale.httpClient(teamscale)
	return http.get {
		request.uri.path = "/p/$project/repository-activity-summary"
		response.failure failure
	}.firstCommit.text() as long
}

/**
 * Creates the issue query defined in ISSUE_QUERY for this project for the month and year defined
 * by the given date.
 */
def createIssueQuery(project, date) {
	date = date.clone()

	def dateShort = date.format("Y-MM")
	def dateFull = { it.format("Y-MM-dd") }

	def name = "Monthly Assessment $dateShort"
	def query = ISSUE_QUERY.replaceAll("START", dateFull(date))

	date.month++
	query = query.replaceAll("END", dateFull(date))

	def http = teamscale.httpClient(teamscale)
	println "Creating Issue Query for $dateShort for \"$project\""
	println "    -> " + http.put {
		request.uri.path = "/p/$project/issue-metrics/$name"
		request.contentType = "application/json"
		request.body = [
			"name" : name,
			"query": query
		]
		response.failure failure
	}
}

/** Returns a date without a time, at the start of the current month */
def getDateAtStartOfCurrentMonth() {
	def date = new Date()
	date.clearTime()
	date.date = 1
	return date
}

/** Checks whether the given project has any issues */
def hasIssues(project) {
	def http = teamscale.httpClient(teamscale)
	return http.get {
		request.uri.path = "/p/$project/issues"
		response.failure failure
	}.childNodes().collect {
		return it.text()
	}.size() > 0
}

/**
 * Creates/adjust the monthly "This Month" and "Previous Month", as well as creating an issue query
 * for the monthly assessment of the last month.
 */
task createMonthlyBaselines {
	doLast {
		getProjects().each { project ->
			def date = getDateAtStartOfCurrentMonth()

			createBaseline project, "This Month", date
			date.month--
			createBaseline project, "Previous Month", date
		}
	}
}

/**
 * Creates an issue query which shows all issues/work items which have been closed
 * in the last month
 */
task createAssessmentIssueQueryForLastMonth {
	doLast {
		getProjects().each { project ->
			if (hasIssues(project)) {
				def date = getDateAtStartOfCurrentMonth()
				date.month--

				createIssueQuery project, date
			} else {
				println "Issue query not created for \"$project\", because it has no issues."
			}
		}
	}
}

/**
 * Goes through all projects and if a project does not have a "Report Last" baseline,
 * it will be created as the first commit of the project (at the very start).
 */
task createReportLastIfMissing {
	doLast {
		getProjects().each { project ->
			if (!getBaselines(project).contains("Report Last")) {
				println "Creating baseline \"Report Last\" for $project"
				createBaseline project, "Report Last", 0
			}
		}
	}
}