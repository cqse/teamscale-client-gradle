apply from: "$rootDir/gradle/base-teamscale.gradle"

import groovy.json.JsonBuilder

ext {
	teamscale.url = "http://..."
	teamscale.username = "admin"
	teamscale.accesskey = "tokentoken"

	// The issue query for the monthly assessment
	// START and END will be replaced with dates
	ISSUE_QUERY = "('Work Item Type' != Task and closed=true and inState(closed=true) >= START and " +
		"inState(closed=true) < END) or ('Work Item Type' = Task and hasParent(closed=true and " +
		"inState(closed=true) >= START and inState(closed=true) < END)) or ('Work Item Type' = Task and " +
		"parent = '' and closed=true and inState(closed=true) >= START and inState(closed=true) < END)"
}

/** Returns all projects currently configured in teamscale */
def getProjects() {
	def http = teamscale.httpClient(teamscale)
	return http.get {
		request.uri.path = "$teamscale.prefix/projects"
		response.failure failure
	}.childNodes().collect {
		return it.text()
	}
}

def createBaseline(project, name, date) {
	def timestamp = Math.max(date.getTime() as long, getFirstCommitTimestamp(project))

	def http = teamscale.httpClient(teamscale)
	return http.put {
		request.uri.path = "$teamscale.prefix/p/$project/baselines/$name"
		request.contentType = "application/json"
		request.body = new JsonBuilder([
			"description": "",
			"name"       : name,
			"timestamp"  : timestamp
		]).toPrettyString()
		response.failure failure
	}
}

/** Returns all currently defined for the given project */
def getBaselines(project) {
	def http = teamscale.httpClient(teamscale)
	return http.get {
		request.uri.path = "$teamscale.prefix/p/$project/baselines"
		response.failure failure
	}.childNodes().collect {
		return it.text()
	}
}

/**
 * Returns the timestamp of the first commit of the given project.
 * Should be used to prevent the creation of a baseline before the project even started.
 */
def getFirstCommitTimestamp(project) {
	def http = teamscale.httpClient(teamscale)
	return http.get {
		request.uri.path = "$teamscale.prefix/p/$project/repository-activity-summary"
		response.failure failure
	}.firstCommit.text() as long
}

/**
 * Creates the issue query defined in ISSUE_QUERY for this project for the month and year defined
 * by the given date.
 */
def createIssueQuery(project, date) {
	date = date.clone()

	def dateShort = date.format("Y-MM")
	def dateFull = { it.format("Y-MM-dd") }

	def name = "Monthly Assessment $dateShort"
	def query = ISSUE_QUERY.replaceAll("START", dateFull(date))

	date.month++
	query = query.replaceAll("END", dateFull(date))

	def http = teamscale.httpClient(teamscale)
	return http.put {
		request.uri.path = "$teamscale.prefix/p/$project/issue-metrics/$name"
		request.contentType = "application/json"
		request.body = [
			"name" : name,
			"query": query
		]
		response.failure failure
	}
}

/** Returns a date without a time, at the start of the current month */
def getDateAtStartOfCurrentMonth() {
	def date = new Date()
	date.clearTime()
	date.date = 1
	return date
}

/** Checks whether the given project has any issues */
def hasIssues(project) {
	def http = teamscale.httpClient(teamscale)
	return http.get {
		request.uri.path = "$teamscale.prefix/p/$project/issues"
		response.failure failure
	}.childNodes().collect {
		return it.text()
	}.size() > 0
}

def log(project, message) {
	println "[$project] $message"
}

/** Creates a baseline at the very start of the project if it has none with that name. */
def createDefaultBaselineIfMissing(project, baseline) {
	if (!getBaselines(project).contains(baseline)) {
		log(project, "Creating baseline: \"$baseline\"")
		createBaseline project, baseline, new Date(0)
	} else {
		log(project, "Skipping")
	}
}

/**
 * Creates/adjust the monthly "This Month" and "Previous Month", as well as creating an issue query
 * for the monthly assessment of the last month.
 */
task createMonthlyBaselines {
	def thisMonth = "This Month"
	def prevMonth = "Previous Month"

	doLast {
		getProjects().each { project ->
			def date = getDateAtStartOfCurrentMonth()

			log(project, "Creating baseline: \"$thisMonth\"")
			createBaseline(project, thisMonth, date)
			date.month--

			log(project, "Creating baseline: \"$prevMonth\"")
			createBaseline project, prevMonth, date
		}
	}
}

/**
 * Creates an issue query which shows all issues/work items which have been closed
 * in the last month
 */
task createAssessmentIssueQueryForLastMonth {
	doLast {
		getProjects().each { project ->
			if (hasIssues(project)) {
				def date = getDateAtStartOfCurrentMonth()
				date.month--

				log(project, "Creating issues query for ${date.format("YY-MM")}")
				createIssueQuery(project, date)
			} else {
				log(project, "Query not created, because it doesn't have any issues")
			}
		}
	}
}

/**
 * Goes through all projects and if a project does not have a "Report Last" baseline,
 * it will be created as the first commit of the project (at the very start).
 */
task createReportLastIfMissing {
	doLast {
		getProjects().each { project ->
			createDefaultBaselineIfMissing(project, "Report Last")
		}
	}
}

/**
 * Goes through all projects and if a project does not have a "TGA Start" baseline,
 * it will be created as the first commit of the project (at the very start).
 */
task createTGAStartIfMissing {
	doLast {
		getProjects().each { project ->
			createDefaultBaselineIfMissing(project, "TGA Start")
		}
	}
}

task createTSAStartIfMissing {
	doLast {
		getProjects().each { project ->
			createDefaultBaselineIfMissing(project, "TSA Start")
		}
	}
}